## 자바 멀티스레드와 동시성

### Reference) 인프런 강의 "김영한의 실전 자바 - 고급 1편, 멀티스레드와 동시성" 을 듣고 중요 내용 정리

<br>

#### 데몬 스레드

스레드는 사용자(user) 스레드와 데몬(daemon) 스레드 2가지 종류로 구분된다.

사용자 스레드
- 프로그램 주요 작업 수행
- 작업이 완료될 때까지 실행
- 모든 user 스레드가 종료되어야 JVM 도 종료된다.

데몬 스레드란
- 백그라운드에서 보조적인 작업 수행
- 모든 user 스레드가 종료되면 데몬 스레드는 자동 종료

JVM 은 데몬 스레드의 실행 완료를 기다리지않고 종료된다. 데몬 스레드가 아닌 모든 스레드가 종료되면, 자바 프로그램도 종료된다
- 언제 종료되어도 상관없는, 백그라운드에서 보조적인 사용하는 경우만 스레드를 데몬 스레드 버전으로 실행하면 될 듯.
- 스레드 실행 전, Thread 클래스의 ```setDaemon(true)``` 기능을 이용하여 데몬 스레드로 설정 가능
    - 데몬 스레드 여부는 기본적으로 false 이다.
 
<br>

#### Thread 상속 vs Runnable 구현

스레드를 생성할 땐 ```Thread``` 클래스를 상속받는 방식보다 ```Runnable``` 인터페이스를 구현하는 방식을 사용하는 것이 좋다.
- 상속의 경우 인터페이스를 사용하는 방식에비해 유연성이 떨어진다.
- 이미 다른 클래스를 상속받고 있는 경우 Thread 상속 불가
- 인터페이스 방식의 경우 스레드와 실행할 작업에 대한 코드를 분리하여 가독성을 높일 수 있다.
    - 코드(Runnable 구현체)의 재사용성도 증가한다.
 
<br>

#### 스레드의 생명 주기
<img width="965" alt="image" src="https://github.com/user-attachments/assets/d43733f4-001f-409e-a474-d01d7d83f32c">
- 스레드가 작업을 기다리고있는 상태에대해서 알아두자.
    - Blocked : 차단 상태로, 스레드가 동기화 락을 기다리는 상태이다.
        - synchronized 블록 진입을 위해 락을 얻어야하는 상태
    - Waiting : 스레드가 무기한으로 다른 스레드의 작업 완료를 기다리는 상태
        - ```wait()```, ```join()``` 메서드가 호출된 상태
    - Timed Waiting : 일정 시간동안 다른 스레드의 작업 완료를 기다리는 상태
        - sleep(ms), wait(timeout), join(ms) 등의 메서드가 호출된 상태

- 스레드가 실행이 완료되거나 예외가 발생해서 Terminated(종료된) 상태로 되면 다시 시작할 수 없다.

<br>

#### 체크 예외 재정의

체크 예외
- 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.

언체크(런타임) 예외
- 예외 처리를 강제하지 않으므로 상관없이 던질 수 있다.

```Runnable``` 인터페이스의 ```run()``` 메서드를 구현할 때 ```InterruptedException``` 체크 예외를 밖으로 던질 수 없다
- 왜 이런걸까?
    - 체크 예외를 `run()` 메서드에서 던질 수 없도록 강제함으로써, 개발자는 반드시 체크 예외를 try-catch 블록 내에서 처리하게 된다
    - 예외 발생 시 예외가 적절히 처리되지 않아서 프로그램이 비정상 종료되는 상황을 방지한다.
    - 특히 멀티스레딩 환경에서는 예외 처리를 강제함으로써 스레드의 안정성과 일관성을 유지할 수 있다.
    - 체크 예외를 강제하는 방식보다 런타임 예외를 활용하자.
 
<br>

#### join

특정 스레드가 완료될 때 까지 기다려야하는 상황이라면 ```join()``` 을 사용하자
- ```join()``` 을 호출하는 스레드는 대상 스레드가 ```TERMINATED``` 상태가 될 때 까지 대기
- 대상 스레드가 ```TERMINATED``` 상태가 되면 호출 스레드는 다시 ```RUNNABLE``` 상태가 되면서 다음 코드를 수행

```join(ms)``` 를 사용하여 특정 시간만큼만 대기할 수도 있다.

<br>

#### 인터럽트 interrupt

특정 스레드의 인스턴스에 ```interrupt()``` 메서드를 호출하면 해당 스레드에 인터럽트가 발생
- 인터럽트 발생 시, 해당 스레드에 ```InterruptedException``` 이 발생
- 즉각적으로 해당 예외가 발생하는 것은 아니고 sleep 처럼 InterruptedException 을 던지는 메서드를 호출하거나, 호출 중일 때 예외가 발생한다.
- 인터럽트를 받은 스레드는 대기 상태에서 깨어나 ```RUNNABLE``` 상태가 되고, 코드를 정상 수행한다.

인터럽트가 적용되고, 인터럽트 예외가 발생하면 해당 스레드는 실행 가능 상태가 되고, 인터럽트 발생 상태도 정상이된다.
- 대기 중인 스레드를 바로 깨워서 실행 가능한 상태로 바꿀 수 있음

yield - 양보하기
- 다른 스레드에게 CPU 실행 기회를 양보할 수 있다.
- 스케줄링 큐에 대기 중인 다른 스레드가 CPU 실행 기회를 더 빨리 얻을 수 있음

<br>

#### volatile 과 메모리 가시성

<img width="715" alt="image" src="https://github.com/user-attachments/assets/45e07cb9-9ffd-4e2e-a459-9258ab4c4091">
두 개의 스레드가 특정 인스턴스의 값을 바라볼 때 중간에 각 CPU 코어의 캐시메모리를 바라보고 있다.
- 스레드에서 수정하는 캐시 메모리 값은 메인메모리에 즉시 반영되지 않는다.
- 메인 메모리 반영 시점은 알 수 없다. CPU 의 설계 방식과 종류에 따라 다르다고 한다.
- 자바에서는 ```volatile``` 이라는 키워드로 메모리 가시성을 보장할 수 있다.
    - 이 키워드를 사용하면 값을 읽을 때, 쓸 때 모두 메인메모리에 접근한다.
    - 성능 저하가 있다.

happens-before
- 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념
- 프로그램 순서 규칙
- volatile 변수
- 스레드 시작 규칙(start 전의 작업), 스레드 종료 규칙(join 전의 작업)
- 인터럽트 규칙
- 객체 생성 규칙
- 모니터 락 규칙
- 전이 규칙
- 등등.. 있다는 것만 알아두자

volatile 또는 스레드 동기화 기법을 사용하면 메모리 가시성의 문제가 발생하지 않는다.

<br>

#### synchronized

여러 방법
- 메서드를 ```synchronized``` 로 선언하여 임계 영역 설정, 동기화 구현
- 코드 블록을 synchronized 로 감싸서 동기화 구현

- synchronized 사용하면 다음 문제를 해결할 수 있다.
    - 경합 조건(Race condition): 두 개 이상의 스레드가 경쟁적으로 동일한 자원을 수정할 때 발생하는 문제
    - 데이터 일관성: 여러 스레드가 동시에 읽고 쓰는 데이터 일관성 문제

장점
- 편리한 사용
- 자동 잠금 해제
- 편리하지만 제공하는 기능이 너무 단순하다.

단점
- 무한대기: ```BLOCKED``` 상태의 스레드는 락이 풀릴 때까지 무한대기한다.
    - 타임아웃 설정 불가
    - 인터럽트 불가
- 공정성: 락이 돌아왔을 때 ```BLOCKED``` 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할지 알 수 없다.

<br>

#### LockSupprot 기능

```LockSupport``` 는 스레드를 ```WAITING``` 상태로 변경한다.
- ```WAITING``` 상태는 누가 깨워주기 전까지는 계속 대기한다. 그리고 CPU 실행 스케줄링에 들어가지 않는다.
- `park()` : 스레드를 `WAITING` 상태로 변경
- unpark(thread)` : `WAITING` 상태의 대상 스레드를 `RUNNABLE` 상태로 변경

LockSupport 는 고급 기능을 구현할 때 활용하기 어려운 저수준의 기능이다.

<br>

#### ReentrantLock

`Lock` 인터페이스는 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데 사용된다.
- `Lock` 인터페이스는 다음과 같은 메서드를 제공한다. 대표적인 구현체로 `ReentrantLock` 이 있다.
- `void lock()`: 락을 획득한다.
    - 다른 스레드가 락을 획득했다면 현재 스레드는 `WAITING` 상태로 들어간다.
    - 이 메서드는 인터럽트에 응답하지 않는다.
- 여기서 사용하는 락은 모니터락이 아니다. 모니터락과 `BLOCKED` 상태는 `synchronized` 에서만 사용된다.

- `void lockInterruptibly()`
    - 락 획득을 시도하는데, 다른 스레드가 인터럽트할 수 있도록한다.
    - 인터럽트 발생 시 인터럽트 예외가 발생하고, 락 획득을 포기한다. 

- `boolean tryLock()`
    - 락 획득을 시도하고, 즉시 성공 여부 반환한다.
 
- `boolean tryLock(long time, TimeUnit unit)`
    - 주어진 시간동안 락 획득을 시도한다.
 
- `void unlock()`
    - 락 해제한다.
    - 락을 획득한 스레드가 호출해야하고, 그렇지 않으면 관련 예외가 발생한다.
 
- `Condition newCondition()`
    - Condition 객체 생성 및 반환, 이 객체는 락과 결합되어 사용된다. 스레드가 특정 조건을 기다리거나 신호를 받을 수 있게한다.

<br>

비공정 모드(Non-fair mode)
- ReentrantLock 의 기본 모드이다.
- 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이 없다.
- 락 획득 속도가 빠르다.
- 새로운 스레드가 기존 스레드보다 락을 먼저 획득할 수 있다.
- 특정 스레드가 계속해서 락을 획득하지 못할 수 있다.

공정 모드(Fair mode)
- 생성자에서 `true` 를 전달하면된다.
- 락을 요청한 순서대로 획득하는 모드이다.
- 성능 저하발생 가능

<br>

#### 생산자 소비자 문제
