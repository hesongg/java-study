
# Java 8, 9, 10 Study
- References) Modern Java in Action (by RAOUL-GABRIEL URMA, MARIO FUSCO, ALAN MYCROFT) 을 읽고 정리
- 참고한 책과 내용이 다를 수 있음
- 소스코드 참고 : http://www.hanbit.co.kr/src/10202

### 스트림 데이터 수집

#### Collector 인터페이스

-	다수준으로 그룹화를 수행할 때 명령형 코드에서는 다중 루프와 조건문이 추가되며 가독성과 유지보수성이 크게 떨어진다. 
반면 함수형 프로그래밍에서는 필요한 컬렉터를 쉽게 추가 할 수 있다.

- 고급 리듀싱 기능을 수행하는 컬렉터
  - 스트림에 collect를 호출하면 스트림의 요소에 리듀싱 연산이 수행된다.

- 미리 정의된 컬렉터 
  -	Collectors 에서 제공하는 메소드의 기능은 크게 세 가지로 구분 할 수 있다.
    -	스트림 요소를 하나의 값으로 리듀스하고 요약
    -	요소 그룹화
    -	요소 분할

- 리듀싱과 요약
  - 스트림 값에서 최댓값과 최솟값 검색
    -	```Collectors.maxBy``` / ```Collectors.minBy``` 두 개의 메소드를 이용해서 스트림의 최대값과 최솟값을 계산 가능
    -	두 컬렉터는 스트림의 요소를 비교하는데 사용 할 Comparator 를 인수로 받는다.
      ```java
      Comparator<Dish> dishCaloriesComparator = Comparator.camparingInt(Dish::getCarolies);
      Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));
      ```
      
  - 요약 연산
    - Collectors 클래스는 ```Collectors.summingInt``` 라는 특별한 요약 팩토리 메소드를 제공한다.
    -	```summingInt```는 객체를 int로 매핑하는 함수를 인수로 받는다.
      ```java
      int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
      ```
      - 추가로 ```summingDouble```, ```summingLong``` 가 있고 평균 계산은 ```averagingInt``` 등이 있다.
    
    -	팩토리 메소드 summarizingInt 가 반환하는 컬렉터 : 하나의 요약 연산으로 요소 수, 합계, 평균, 최댓값, 최솟값 계산 가능
      ```java
      IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));
      ```
      - 위 코드를 실행하면 IntSummaryStatistics 클래스로 모든 정보가 수집된다. 
        - menuStatistics 객체를 출력하면 다음과 같은 정보가 확인된다.
          - ```IntSummaryStatistics{count=9, sum=4300, min=120, average=477.778, max=800}```
          - 마찬가지로 int 뿐만아니라 long이나 double에 대응하는 ```summarizingLog```, ```summarizingDouble``` 
          - 메소드와 관련된 ```LongSummaryStatistics```, ```DoubleSummaryStatistics``` 클래스도 있다.

  - 문자열 연결
    - 컬렉터에 ```joining``` 팩토리 메소드를 이용하면 스트림의 각 객체에 toString 메소드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다.
      - ex) 메뉴의 모든 요리명 연결
          ```java
          String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining());
          ```
          - 연결된 두 요소 사이에 문자열을 넣을 수 있도록 오버로드된 joining 팩토리 메소드도 있다.
          ```java
          String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining(", "));
          ```
  - 범용 리듀싱 요약 연산
    - 범용 ```Collectors.reducing``` 으로도 구현 가능
      - ex) 모든 칼로리 합계
        ```java
        int totalCalories = menu.stream().collect(Collectors.reducing(0, Dish::getCalories, (i, j) -> i+j));
        ```
      - reducing은 인수 3개를 받는다.
        -	첫 번째 인수는 리듀싱 연산의 시작 값이거나 스트림에 인수가 없을때는 반환 값이다.
        -	두 번째 인수는 변환 함수
        -	세 번째 인수는 같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator
        -	한 개의 인수를 갖는 reducing 은 Optional<Dish> 객체를 반환한다. (현재 예제에서)

  
- 스트림 인터페이스에서 직접 제공하는 메소드를 이용하는 것에 비해 컬렉터를 이용하는 코드가 더 복잡하다. 
  코드가 복잡한 대신 재사용성과 커스터마이즈 가능성을 제공하는 높은 수준의 추상화와 일반화를 얻을 수 있다.
  
- 그룹화
  - 명령형으로 그룹화를 구현하려면 까다롭다.
  - 함수형을 이용하면 가독성있는 한 줄의 코드로 그룹화 구현 가능.
  -	다음 처럼 팩토리 메서드 ```Collectors.groupingBy``` 를 이용해서 쉽게 메뉴를 그룹화 할 수 있다.
	  ```java
    Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
                                      .collect(groupingBy(Dish::getType));
    ```
	  - Map에 포함된 결과 : {Fish=[prawns, salmon], OTHER=[…], MEAT=[pork, beef]}
  
  - groupingBy 메소드를 분류 함수라고한다. 각 키에 대응하는 스트림의 모든 항목 리스트를 값으로 갖는 맵이 반환

  - 사용 예시) 400칼로리 이하를 ‘diet’ 로, 400~700 을 ‘normal’ , 700 이상을 ‘fat’ 으로 그룹화
    ```java
    public enum CaloricLevel { DIET, NORMAL, FAT }

    Map <CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream.collect(
      groupingBy(dish -> {
        if(dish.getCalories() <= 400) return CaloricLevel.DIET;
        else if(dish.getCalories() <= 700) return CaloricLevel.NORMAL;
        else return CaloricLevel.FAT;
      })
    );
    ```
  
  - 그룹화된 요소 조작
    - filtering 메소드는 Collectors 클래스의 또 다른 정적 팩토리 메소드로 프레디케이트를 인수로 받는다. 
      이 프레디케이트로 각 그룹의 요소와 필터링된 요소를 재그룹화 한다.
      ```java
      Map<Dish.Type List<Dish>> caloricDishesByType = menu.stream().
		        collect(groupingBy(Dish::getType, filtering(dish -> dish.getCalories() > 500, toList())));
      ```
      - menu.stream() 다음 .filter 를 쓰는 것과의 차이는 목록이 비어있는 항목도 추가 된다.
  
  - 그룹화된 항목을 조작하는 다른 유용한 기능 중 또 다른 하나로 맵핑 함수를 이용해 요소를 변환하는 작업이 있다.
  예를 들어 이 함수를 이용해 그룹의 각 요리를 관련 이름 목록으로 변환 할 수 있다.
    ```java
    Map<Dish.Type List<String>> dishNamesByType = menu.stream().
		collect(groupingBy(Dish::getType, mapping(Dish::getName, toList())));
    ```
    - 참고) flatMapping 도 있음

  - 다수준 그룹화
    - Collectors.groupingBy 는 일반적인 분류 함수와 컬렉터를 인수로 받는다.
    - 외부 groupingBy 안에 내부 groupingBy 를 두어서 두 수준으로 스트림의 항목을 그룹화 할 수 있다. (Map 안에 Map)
  
  - 서브그룹으로 데이터 수집
    - groupingBy 로 넘겨주는 컬렉터의 형식은 제한이 없다.
      - ex) groupingBy 컬렉터에 두 번째 인수로 counting 컬렉터를 전달해서 메뉴에서 요리의 수를 종류별로 계산
        ```java
        Map<Dish.Type, Long> typesCount = menu.stream().
                collect(groupingBy(Dish::getType, counting()));
        ```
        - 참고) ```Collectors.collectingAndThen``` 컬렉터, 변환함수

    -	한 개의 인수를 갖는 ```groupingBy(f)``` 는 ```groupingBy(f, toList())```의 축약형이다.
    -	인수를 추가해서 어떤 타입으로 리턴할지도 정할 수 있다.
    -	```toCollection``` 을 이용해서 원하는 방식으로 결과 제어 가능 ex) ```toCollection(HashSet::new)```


- 분할 ```partitioningBy```
  ```java
  Map<boolean, List<Dish>> partitionedMenu = menu.stream()
                    .collect(partitioningBy(Dish::isVegetarian));
  ```
  - 위 코드를 실행하면 다음과 같은 맵이 반환된다. ```{false={port, …}, true={rice, …}}```
  - 이제 참 값의 키로 맵에서 모든 채식 요리를 얻을 수 있다.
    ```java
    List<Dish> vegetarianDishes = partitionedMenu.get(true);
    ```
  -	```partitioningBy``` 도 ```groupingBy``` 와 같이 컬렉터를 두 번째 인수로 전달할 수 있는 오버로드된 버전의 partitionBy메소드도 있다.

  
  |팩토리메서드|반환형식|사용 예제|
  |-----------|--------|--------|
  |reducing|The type produced by the reduction operation|누적자를 초깃값으로 설정한 다음에 BinaryOperator로 스트림의 각 요소를 반복적으로 누적자와 합쳐 스트림을 하나의 값으로 리듀싱|
  |활용 예<br>```int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum))```|
  |활용 예<br>``````|||
  |collectingAndThen|||
  |활용 예<br>``````|||
  |groupingBy|||  
  |활용 예<br>``````|||
  |PartitioningBy|||
  |활용 예<br>``````|||
  |summarizing|||
  |활용 예<br>``````|||  
  |joining|||  
  |활용 예<br>``````|||
  |maxBy|||
  |활용 예<br>``````|||
  |minBy|||
  |활용 예<br>```Optional<Dish> lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories)));```|||
 


