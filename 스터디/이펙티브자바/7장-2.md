## 이펙티브 자바 스터디

### 7장. 람다와 스트림

<br>

#### 아이템44. 표준 함수형 인터페이스를 사용하라

- 템플릿 메서드 패턴
    - 상위 클래스의 기본 메서드를 오버라이딩해서 구현하는 패턴
    - 알고리즘 구조를 상위 클래스에서 정의하고, 구현 클래스에서 알고리즘의 특정 단계들을 구체화
    - 장점 : 코드 중복 제거, 자식 클래스의 역할을 줄임
    - 단점 : 로직을 사용하는 클라이언트의 동작이 상위 클래스의 알고리즘에 의해서 제한됨, 리스코프 치환 원칙 위배

- 책 내용으로는.. 템플릿 메서드 패턴은 이제 잘 사용되지않고 대신에 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자 제공?
    - 함수 객체를 파라미터로 받는 생성자와 메서드를 더 많이 만들어야 한다.

- 이렇게 예시를 들 수 있을지..
    - 템플릿 메서드 패턴
        ```java
        abstract class PrintCondition {
            public void printAndResult() {
                boolean andResult = firstCondition() && secondCondition();
                System.out.println("and result : " + andResult);
            }

            abstract boolean firstCondition();
            abstract boolean secondCondition();
        }
        ```
    - 모던 자바에서의 개선
        ```java // 수정 필요
        class PrintCondition {
            public void printAndResult() {
                boolean andResult = firstCondition() && secondCondition();
                System.out.println("and result : " + andResult);
            }

            boolean firstCondition();
            boolean secondCondition();
        }
        ```

- 필요한게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 찾아보고 활용하자.
    - ```java.util.function``` 패키지 - 총 43개의 함수형 인터페이스가 있다.

- 위 예시를 추가로 개선? BiPredicate 참고
    ```java

    ```

- ```java.util.function``` 에 있는 기본 인터페이스 6개만 기억하면 나머지들은 유추 가능하다.
    - Operator : 인수 개수에 따라 아래와 같이 나눠짐, 반환 값과 인수의 타입이 같음
        - UnaryOperator<T>
            - 메서드 시그니처 : ```T apply(T t)```
            - 예시 : ```String::toLowerCase```
        - BinaryOperator<T>
            - 메서드 시그니처 : ```T apply(T t1, T t2)```
            - 예시 : ```BigInteger::add```
    - Predicate<T> : 인수 하나를 받아 boolean 반환
        - 메서드 시그니처 : ```boolean test(T t)```
        - 예시 : ```Collection::isEmpty```
    - Function<T,R> : 인수와 반환 타입이 다름
        - 메서드 시그니처 : ```R apply(T t)```
        - 예시 : ```Arrays::asList```
    - Supplier<T> : 인수를 받지않고 값을 반환
        - 메서드 시그니처 : ```T get()```
        - 예시 : ```Instant::now```
    - Consumer<T> : 인수를 하나 받고 반환값이 없음
        - 메서드 시그니처 : ```void accept(T t)```
        - 예시 : ```System.out::println```

- 보통 기본 타입 int, long, double 용으로 변형 생긴 버전이 있다.
    - (boolean 타입과 관련된 변형 버전은 유일하게 BooleanSupplier 가 존재한다.)
    - Function 인터페이스는 입력과 결과 타입이 다르므로 많은 변형 버전이 있음

- 표준 함수형 인터페이스 대부분 기본 타입만 지원
    - ```"기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자"```
    - 참조타입을 쓰는 경우 고려 후 사용

- 필요한 경우 직접 구현하여 사용
    - 구조적으로 같은 표준 함수형 인터페이스가 있더라도 직접 구현 필요한 경우가 있다.
    - 예시) Comparator<T> 는 ToIntBiFUnction<T,U> 와 구조적으로 동일하다. 하지만
        - 1. Comparator 라는 네이밍이 용도를 구체적으로 표현 가능하다.
        - 2. 구현하는 쪽에서 반드시 지켜야 할 규약을 담고 있다.
            - 규약을 담고있다는게 정확히 어떤 말일까?
                - 인터페이스 자체로 용도를 표현
        - 3. 유용한 디폴트 메서드를 제공한다.

- 함수형 인터페이스 작성시 주의
    - ```@FunctionalInterface``` 애너테이션을 항상 사용할 것
        - 람다용으로 설계되었다고 표시해야한다.
        - 컴파일 오류로 해당 인터페이스 추가 구현 시의 문제 예방
            - 유지보수를 하면서 추상 메서드를 추가한다던지.. 등
    - 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의하면 안된다.
        ```java
        java.util.concurrent.ExecutorService
        
        <T> Future<T> submit(Callable<T> task);

        <T> Future<T> submit(Runnable task, T result);
        ```
        - 올바른 메서드를 알려주기 위해 형변환 해야할 때가 생기기 때문
        - 다중정의(overloading) 을 주의하자.

<br>

#### 아이템45. 스트림은 주의해서 사용하라

- 스트림에서 원소로 사용 가능한 예시
    - 컬렉션, 배열, 파일, 정규표현식 패턴 matcher, 난수 생성기, 다른 스트림
 
- 기본타입 값들을 다루는데 특화된 IntStream, LongStream, DoubleStream 이 존재한다.
    - 해당 스트림을 사용한다고 추가되는 기능은 따로 없고 boxing/unboxing 관련 효율성에 이점이 있다.

- 스트림 연산은 하나 이상의 중간 연산과 최종 연산이 가능
    - 중간 연산 : 스트림을 변환 및 가공
    - 최종 연산 : 중간 연산의 결과에 마지막 연산 수행하여 결과를 도출한다.

- 스트림의 lazy 한 특성 - 지연 연산 (lazy evaluation)
    - 최종 연산이 호출될 때 계산을 수행한다. (실행 결과가 필요하기전까지 연산을 수행하지않음)
    - 참고) ```peek()``` 중간 연산자로 스트림 중간연산 값 디버깅이 가능하다.
    - 스트림의 지연 연산과 최적화 전략
        - 루프 퓨전(loop fusion) : 파이프라인에서 연속적인 스트림 연산을 하나의 연산 과정으로 병합시키는 것
            - 스트림의 개별 요소에 대한 접근 횟수를 줄이는 최적화 전략이라고 보면된다.
        - 쇼트 서킷(short circuit) : 불필요한 연산 과정을 생략해서 실행 속도를 높인다.
            - 예로 filter 중간 연산으로 걸러진 요소들은 연산 과정에서 생략된다고 생각하면된다.
        - 최적화가 이상적으로 되지않는 케이스도 있다
            - 중간에 sorted 같은 연산이 들어가게되면 정렬을 수행해야하기때문에 스트림의 모든 요소가 연산 수행대상이된다.
            - 무한 스트림에서 limit 하기전에 sorted 를 수행하게된다면..?
        - 참고) https://bugoverdose.github.io/development/stream-lazy-evaluation/

- 스트림 API 는 플루언트(fluent) API 다.
    - 메서드 체이닝 가능
    - 단 하나의 표현식으로 구현 가능

- 파이프라인 병렬 수행 필요 시 ```parallel``` 메서드 호출 - 주의
    - (아이템 48)

- 스트림을 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.
    - 책 예시는 생략
    - 스트림을 과도하게 사용한다면.. 로직을 직관적으로 파악하기 힘들다.
        - 스트림 연산에서 로직을 람다와 메서드 참조로만 구현하면 보기 힘든 코드가 생긴다.
    - 로직을 구현한 메서드와 스트림을 적절하게 사용해서 가독성 좋은 코드를 작성하자.

- 람다 파라미터의 네이밍
    - 람다에서는 타입 이름을 자주 생략하므로 파라미터명을 잘 지어야 파이프라인 가독성이 유지된다.
 
- 책의 예시에 나와있는데, 스트림 내부의 디테일한 로직은 스트림을 사용하지않고 커스텀 메서드로 구현하는 것을 고려하자.

- 람다 vs 코드 블록```{}```
    - 코드 블록에서는 범위 안의 지역변수를 읽고 수정가능
        - 람다에서는 final 변수만 읽을 수 있고, 지역변수 수정 불가능
    - 코드 블록에서는 return 문이나 break, continue 문 활용 가능하다.
    - 원소들을 대상으로 변환, 필터링 등 일관적인 작업을 하는 경우는 일반적으로 스트림이 더 유용하다.

- 스트림은 연산을 수행하면서 아이템을 소비하기때문에 여러 연산에서 동시에 해당 아이템에 접근할수는 없다.

- 정리) 무조건 스트림만 사용하는 방법은 좋지않다. 적절하게 사용하자


<br>

#### 아이템46. 스트림에서는 부작용 없는 함수를 사용하라

- 스트림 패러다임을 이해하자. (함수형 프로그래밍)
    - 스트림 연산에서는 순수 함수만을 사용할 것
    - 순수 함수? : 입력만이 결과에 영향을 주는 함수

- 좋지않은 코드 예시
    ```java
    Map<String, Long> freq = new HashMap<>();
    try (Stream<String> words = new Scanner(file).tokens()) {
        words.forEach(word -> {
            freq.merge(word.toLowerCase(), 1L, Long::sum);
        }
    }
    ```
    - 스트림, 람다, 메서드 참조등을 사용했지만 기존 반복 코드와 큰 차이가 없다.
      
- 개선 코드
    ```java
    Map<String, Long> freq;
    try (Stream<String> words = new Scanner(file).tokens()) {
        freq = words.collect(groupingBy(String::toLowerCase, counting()));
    }
    ```
    - 함수형 프로그래밍으로 명확하게 개선되었다.

- forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 경우는 쓰지 말자.
    - 계산 결과를 기존 컬렉션에 추가하는 등의 용도로 쓸 수는 있다.
 
- ```Collector```
    - 최종 연산에서 스트림의 원소를 컬렉션으로 만들기위해 사용하는 인터페이스
    - 참고) Collector.toList & Stream.toList
        - toList()
            - 변경 가능
            - null 값 허용
        - toUnmodifiableList()
            - 수정이 불가
            - null 값 허용되지 않음
        - Stream.toList()
            - 수정이 불가
            - null 값 허용
    - ```toMap(keyMapper, valueMapper)```
        - 스트림 원소를 key Function, value Function 의 인수로 사용하여 맵으로 만든다
        - 인수 3개를 받는 toMap
            - 3번째 인수 타입 : ```BinaryOperator<U> mergeFunction```
            - 병합 함수를 받아서 머지에 사용



<br>

#### 아이템47. 반환 타입으로는 스트림보다 컬렉션이 낫다

<br>

#### 아이템48. 스트림 병렬화는 주의해서 적용하라




