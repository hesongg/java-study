## 이펙티브 자바 스터디

### 7장. 람다와 스트림

<br>

#### 아이템44. 표준 함수형 인터페이스를 사용하라

- 템플릿 메서드 패턴
    - 상위 클래스의 기본 메서드를 오버라이딩해서 구현하는 패턴
    - 알고리즘 구조를 상위 클래스에서 정의하고, 구현 클래스에서 알고리즘의 특정 단계들을 구체화
    - 장점 : 코드 중복 제거, 자식 클래스의 역할을 줄임
    - 단점 : 로직을 사용하는 클라이언트의 동작이 상위 클래스의 알고리즘에 의해서 제한됨, 리스코프 치환 원칙 위배

- 책 내용으로는.. 템플릿 메서드 패턴은 이제 잘 사용되지않고 대신에 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자 제공?
    - 함수 객체를 파라미터로 받는 생성자와 메서드를 더 많이 만들어야 한다.

- 이렇게 예시를 들 수 있을지..
    - 템플릿 메서드 패턴
        ```java
        abstract class PrintCondition {
            public void printAndResult() {
                boolean andResult = firstCondition() && secondCondition();
                System.out.println("and result : " + andResult);
            }

            abstract boolean firstCondition();
            abstract boolean secondCondition();
        }
        ```
    - 모던 자바에서의 개선
        ```java // 수정 필요
        class PrintCondition {
            public void printAndResult() {
                boolean andResult = firstCondition() && secondCondition();
                System.out.println("and result : " + andResult);
            }

            boolean firstCondition();
            boolean secondCondition();
        }
        ```

- 필요한게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 찾아보고 활용하자.
    - ```java.util.function``` 패키지 - 총 43개의 함수형 인터페이스가 있다.

- 위 예시를 추가로 개선? BiPredicate 참고
    ```java

    ```

- ```java.util.function``` 에 있는 기본 인터페이스 6개만 기억하면 나머지들은 유추 가능하다.
    - Operator : 인수 개수에 따라 아래와 같이 나눠짐, 반환 값과 인수의 타입이 같음
        - UnaryOperator<T>
            - 메서드 시그니처 : ```T apply(T t)```
            - 예시 : ```String::toLowerCase```
        - BinaryOperator<T>
            - 메서드 시그니처 : ```T apply(T t1, T t2)```
            - 예시 : ```BigInteger::add```
    - Predicate<T> : 인수 하나를 받아 boolean 반환
        - 메서드 시그니처 : ```boolean test(T t)```
        - 예시 : ```Collection::isEmpty```
    - Function<T,R> : 인수와 반환 타입이 다름
        - 메서드 시그니처 : ```R apply(T t)```
        - 예시 : ```Arrays::asList```
    - Supplier<T> : 인수를 받지않고 값을 반환
        - 메서드 시그니처 : ```T get()```
        - 예시 : ```Instant::now```
    - Consumer<T> : 인수를 하나 받고 반환값이 없음
        - 메서드 시그니처 : ```void accept(T t)```
        - 예시 : ```System.out::println```

- 보통 기본 타입 int, long, double 용으로 변형 생긴 버전이 있다.
    - (boolean 타입과 관련된 변형 버전은 유일하게 BooleanSupplier 가 존재한다.)
    - Function 인터페이스는 입력과 결과 타입이 다르므로 많은 변형 버전이 있음

- 표준 함수형 인터페이스 대부분 기본 타입만 지원
    - ```"기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자"```
    - 참조타입을 쓰는 경우 고려 후 사용

- 필요한 경우 직접 구현하여 사용
    - 구조적으로 같은 표준 함수형 인터페이스가 있더라도 직접 구현 필요한 경우가 있다.
    - 예시) Comparator<T> 는 ToIntBiFUnction<T,U> 와 구조적으로 동일하다. 하지만
        - 1. Comparator 라는 네이밍이 용도를 구체적으로 표현 가능하다.
        - 2. 구현하는 쪽에서 반드시 지켜야 할 규약을 담고 있다.
            - 규약을 담고있다는게 정확히 어떤 말일까?
                - 인터페이스 자체로 용도를 표현
        - 3. 유용한 디폴트 메서드를 제공한다.

- 함수형 인터페이스 작성시 주의
    - ```@FunctionalInterface``` 애너테이션을 항상 사용할 것
        - 람다용으로 설계되었다고 표시해야한다.
        - 컴파일 오류로 해당 인터페이스 추가 구현 시의 문제 예방
            - 유지보수를 하면서 추상 메서드를 추가한다던지.. 등
    - 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의하면 안된다.
        ```java
        java.util.concurrent.ExecutorService
        
        <T> Future<T> submit(Callable<T> task);

        <T> Future<T> submit(Runnable task, T result);
        ```
        - 올바른 메서드를 알려주기 위해 형변환 해야할 때가 생기기 때문
        - 다중정의(overloading) 을 주의하자.

<br>

#### 아이템45. 스트림은 주의해서 사용하라

- 스트림에서 원소로 사용 가능한 예시
    - 컬렉션, 배열, 파일, 정규표현식 패턴 matcher, 난수 생성기, 다른 스트림
 
- 기본타입 값들을 다루는데 특화된 IntStream, LongStream, DoubleStream 이 존재한다.
    - 해당 스트림을 사용한다고 추가되는 기능은 따로 없고 boxing/unboxing 관련 효율성에 이점이 있다.

- 스트림 연산은 하나 이상의 중간 연산과 종단 연산이 가능
    - 중간 연산 : 스트림을 변환 및 가공
    - 종단 연산 : 중간 연산의 결과에 마지막 연산 수행하여 결과를 도출한다.

- 스트림의 lazy 한 특성 - 지연 연산 (lazy evaluation)
    - 종단 연산이 호출될 때 계산을 수행한다. (실행 결과가 필요하기전까지 연산을 수행하지않음)
    - 참고) ```peek()``` 중간 연산자로 스트림 중간연산 값 디버깅이 가능하다.
    - 스트림의 지연 연산과 최적화 전략
        - 루프 퓨전(loop fusion) : 파이프라인에서 연속적인 스트림 연산을 하나의 연산 과정으로 병합시키는 것
            - 스트림의 개별 요소에 대한 접근 횟수를 줄이는 최적화 전략이라고 보면된다.
        - 쇼트 서킷(short circuit) : 불필요한 연산 과정을 생략해서 실행 속도를 높인다.
            - 예로 filter 중간 연산으로 걸러진 요소들은 연산 과정에서 생략된다고 생각하면된다.
        - 최적화가 이상적으로 되지않는 케이스도 있다
            - 중간에 sorted 같은 연산이 들어가게되면 정렬을 수행해야하기때문에 스트림의 모든 요소가 연산 수행대상이된다.
            - 무한 스트림에서 limit 하기전에 sorted 를 수행하게된다면..?
        - 참고) https://bugoverdose.github.io/development/stream-lazy-evaluation/

- 스트림 API 는 플루언트(fluent) API 다.
    - 메서드 체이닝 가능
    - 단 하나의 표현식으로 구현 가능

- 파이프라인 병렬 수행 필요 시 ```parallel``` 메서드 호출 - 주의
    - (아이템 48)

- 스트림을 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.

- 



<br>

#### 아이템46. 스트림에서는 부작용 없는 함수를 사용하라

<br>

#### 아이템47. 반환 타입으로는 스트림보다 컬렉션이 낫다

<br>

#### 아이템48. 스트림 병렬화는 주의해서 적용하라




