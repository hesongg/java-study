## 이펙티브 자바 스터디

### 8장. 메서드

<br>

#### 아이템52. 다중정의는 신중히 사용하라

- 컬렉션을 집합, 리스트, 그 외로 구분하기 위해 만든 책의 예시 코드
    ```java
    public class Main {

        public static String classify(Set<?> s) {
            return "집합";
        }
        public static String classify(List<?> l) {
            return "리스트";
        }
        public static String classify(Collection<?> c) {
            return "그 외";
        }
    
        public static void main(String[] args) {
            Collection<?>[] collections = {
                    new HashSet<String>(),
                    new ArrayList<BigInteger>(),
                    new HashMap<String, String>().values()
            };
    
            for (Collection<?> c : collections) {
                System.out.println(classify(c));
            }
        }
    }
    ```
    - 호출 시 "그 외" 만 세 번 연달아 출력된다.
    - 다중 정의(overloading)된 메서드 중 어느 메서드를 호출하는지가 컴파일타임에 정해지기 때문이다.
    - 컴파일타임에 c 는 항상 ```Collection<?> c``` 타입이다.
        - 런타임에는 타입이 매번 달라지지만, 호출을 메서드를 선택하는데 영향을 줄 수 없음
        - 따라서 컴파일타임의 매개변수 타입을 기준으로 세 번째 메서드만 수행함

- 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다.
    - 재정의 메서드는 런타임에 객체의 실제 타입에 따라 실행되고, 다중정의 메서드는 컴파일 타임에 매개변수에 따라서 실행되기 때문이다.

- 아까의 예시 코드를 아래와 같이 인스턴스 체크하도록 변경하면 정상 동작
    ```java
    public static String classifyVer2(Collection<?> c) {
        return c instanceof Set ? "집합2"
                : c instanceof List ? "리스트2"
                : "그 외2";
    }
    ```

- 다중정의가 혼동을 일으키는 상황을 피하자.

- 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.

- 가변인수(Variable Arguments) 를 사용하는 메서드라면 다중정의 아예 하지말자

- 다중정의하는 대신 메서드 이름을 다르게 지어서 표현하는 방식도 있다.

- 생성자 다중정의 관련 내용
    - 생성자는 이름을 다르게 지을 수 없으므로, 두 번째 생성자부터는 무조건 다중정의가 된다.
    - 정적 팩터리라는 대안 활용하자.
 
- ```"매개변수 수가 같은 다중정의 메서드가 많더라도, 어느 메서드가 주어진 매개변수들을 처리할지 명확히 구분된다면 헷갈일 일은 없다"```
    - 매개변수 하나 이상이 근본적으로 다르다? -> 두 타입의 값을 서로 어느 쪽으로든 형변환 불가능
    - 이 조건이면 어느 다중 정의 메서드를 호출할지가 매개변수들의 런타임 타입만으로 결정이 된다.
    - 예시) ArrayList 생성자
        ```java
        public ArrayList(int initialCapacity) {
            if (initialCapacity > 0) {
                this.elementData = new Object[initialCapacity];
            } else if ...
        }
    
        public ArrayList(Collection<? extends E> c) {
            Object[] a = c.toArray();
            ...
        }
        ```
        - 생성자의 두 매개변수 타입이 근본적으로 다르기 때문에 맨 처음보였던 예시와 같이 헷갈일 일이 없다는 것 같다.

- list remove 예시
    - List 의 remove 메서드 오버로딩
        ```java
        E remove(int index);

        boolean remove(Object o);
        ```
    - int 값을 가지는 list 에서 특정 값 remove 를 위해선 형변환 필요
        ```java
        list.remove((Integer) i); // 혹은 remove(Integer.valueOf(i))
        ```

- 람다와 메서드 참조에서 다중정의 혼란 예시
    ```java
    new Thread(System.out::println).start();

    ExecutorService exe = Executors.newFixedThreadPool(1);
    exe.submit(System.out::println); // 컴파일 오류 발생
    ```
    - submit 이 Runnable, Callable 을 각각 받는 메서드로 다중정의되어있지만, 다중정의된 println 은 항상 void 이다. 왜 문제가 생기는걸까?
        - println 이 만약 다중정의되어있지 않았다면 정상 동작 -> submit, println 둘다 다중정의되어서 문제가 발생함
        - 뭔가 기술적인 알고리즘으로 인해 컴파일 오류가 발생한다고하는데 딱히 몰라도 될듯
    - 다중정의된 메서드들이 함수형 인터페이스를 인수로 받을 때, 서로 다른 함수형 인터페이스라도 인수 위치가 같으면 혼란이 생긴다는 점을 기억하자.
 
- 이와 같은 이유로 메서드 다중정의시, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받지말자.

- 자바 버전업에 따라서 다중정의 메서드 선택 규칙은 더 복잡해지고 있기 때문에 잘고려해서 사용하자.

<br>

#### 아이템53. 가변인수는 신중히 사용하라

- 가변인수(Variable Arguments) 메서드 : 명시한 타입의 인수를 0개 이상 받을 수 있는 메서드

- 가변인수 메서드 호출 시 인수 개수와 같은 길이를 가지는 배열을 만들고 인수들을 배열에 저장, 가변인수 메서드에 넘겨줌

- 가변인수는 인수 개수가 정해지지 않았을 때 아주 유용하다.
    - 예시) ```printf```
 
- 성능에 민감하다면 가변인수는 안좋을 수 있음
    - 메서드 호출시 마다 배열을 새로 할당 및 초기화 수행
    - 관련해서 선택 가능한 패턴 : 메서드 호출의 대부분이 인수를 특정 개수 이하로 사용한다면 해당 인수 개수까지 인수 개수 별로 메서드를 오버로딩 해놓는 방법
        - EnumSet 의 정적 팩터리 메서드도 동일한 패턴으로 구현되어 있다.
        - 인수 1~5개까지는 인수 개수 별로 of 메서드 구현, 그 이상은 필수 매개변수와 가변 인수로 구현
            ```java
            @SafeVarargs
            public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest) {
                EnumSet<E> result = noneOf(first.getDeclaringClass());
                result.add(first);
                for (E e : rest)
                    result.add(e);
                return result;
            }
            ```
            - first 매개변수를 필수로 받아서 하나 이상의 인수를 가지는 것을 보장한다.
            - 참고) ```@SafeVarargs```
                - 제네릭 가변인수를 받는 메서드가 Type Safety 하다는 것을 선언하여 Heap Pollution 경고 억제 용도로 사용
                - Heap Pollution?
                    - 제네릭을 잘못 사용하여 런타임에 ClassCastException 과 같은 오류가 발생할 수 있다는 경고
                - final / static 메소드 / 그리고 Java 9 이후부터는 private 인스턴스 메소드에도 적용 가능
                    - 왜 해당 메서드 타입에서만 사용 가능할까?
                    - final
                        - final 메서드는 오버라이드될 수 없으므로, 메소드 내부에서 타입 안전성을 보장하는 한, 외부에서 타입 안전성을 해치는 확장이 불가능
                    - static: 정적 메소드 역시 인스턴스에 종속되지 않으며, 오버라이드될 수 없어 타입 안전성을 보장 가능
                    - private 인스턴스 메서드(Java 9 이상): private 메소드는 클래스 외부에서 접근할 수 없으며, 오버라이드될 수 없기때문에 타입 안정성 보장 가능
                ```java
                //@SafeArgs 없으면 Possible heap pollution from parameterized vararg type
                @SafeVarargs
                public static <T> void printItemsVarargs(T... items) {
                    for (T item : items) {
                        System.out.println(item);
                    }
                }
            
                public static void printItems(String... items) {
                    for (String item : items) {
                        System.out.println(item);
                    }
                }
                ```
 
- 인수 개수가 일정하지 않은 메서드를 정의해야한다면 가변인수를 사용해야하는데
    - 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두자
    - 가변인수 사용시에 성능문제를 고려하자

<br>

#### 아이템54. null이 아닌, 빈 컬렉션이나 배열을 반환하라



<br>

#### 아이템55. 옵셔널 반환은 신중히 하라



<br>

#### 아이템56. 공개된 API 요소에는 항상 문서화 주석을 작성하라



<br>
