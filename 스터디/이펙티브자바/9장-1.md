## 이펙티브 자바 스터디

### 9장. 일반적인 프로그래밍 원칙

<br>

#### 아이템57. 지역변수의 범위를 최소화하라

- ```"지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다"```
    - 변수는 기능을 구현하기위한 최소한의 동작 단위로 제공을하면 좋다는 말인 것 같다.

- 지역변수의 범위를 줄이는 방법
    - 가장 처음 쓰일 때 선언하기
        - 미리 선언부터 해두면 코드의 가독성이 떨어진다.
        - 실수 유발
    - 거의 모든 지역변수는 선언과 동시에 초기화해야 한다.
        - 초기화에 필요한 정보가 충분하지않다면 선언을 미루자
    - 메서드를 작게 유지하고 한 가지 기능에 집중하는 것
        - 한 메서드에서 여러 가지 기능을 처리하다보면 연관없는 지역변수끼리 간섭이 발생할 수 있음
        - 이런 경우 단순히 메서드를 기능별로 쪼개면 해결된다.

<br>

#### 아이템58. 전통적인 for 문 보다는 for-each 문을 사용하라

- for 문 대신 for-each 문을 사용하면 해결되는 문제
    - 반복자와 인덱스 변수는 코드를 지저분하게 한다.
    - 원소만 필요한 상황에서 불필요한 인덱스 사용
    - 요소 종류가 늘어나면 오류가 생길 가능성이 높아진다.
    - 컬렉션이냐 배열에 따라 코드 형태가 상당히 달라진다.
 
- for-each 문 (향상된 for 문)
    - 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 인덱스 사용관련 오류 발생할 일이 없다.
    - 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있다
        ```java
        for (Element e : elements) {
            ...
        }
        ```
        
- for-each 문 사용 불가능한 상황
    - 파괴적인 필터링 (destructive filtering) -> 원소를 제거하는 필터링 과정
        - 컬렉션을 순회하면서 선택된 원소를 제거하려면 반복자의 remove 메서드 호출 필요
        - 자바 8 부터 도입된 Collection 의 removeIf 메서드를 사용해서 명시적으로 순회하지않아도 된다.
    - 변형 (transforming)
        - 컬렉션 순회하면서 원소의 값 일부나 전체를 교체해야한다면 리스의 반복자나 배열의 인덱스를 사용해야한다.
    - 병렬 반복 (parallel iteration)
        - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

- 위의 상황들을 경계하면서 사용하자.

- for-each 문은 컬렉션과 배열, Iterable 인터페이스를 구현한 객체라면 무엇이든 순회 가능하다.

<br>

#### 아이템59. 라이브러리를 익히고 사용하라

- 표준 라이브러리를 활용하자.
    - 대표적인 예시 : ```Random.nextInt(int)```
    - 자바 7부터는 ```ThreadLocalRandom``` 를 사용하자.
        - 멀티스레딩 환경에서 발생하는 Random 의 스레드 경합 문제를 해결한다.
    - ForkJoinPool 이나 병렬 스트림에서는 SplittableRandom 사용하자
     
- 표준 라이브러리 사용 이점
    - 히스토리 많음
    - 핵심적인 일과 관련없는 문제에 시간 허비를 안해도 된다.
    - 지속적인 성능 개선
    - 기능 업데이트
    - 다른 사람에게 낯익은 코드가 된다. (가독성 증가)
 
- 익숙해질 필요가 있는 라이브러리
    - ```java.lang```, ```java.util```, ```java.io``` 하위 패키지 등
    - 컬렉션 프레임워크, 스트림, java.util.concurrent 의 동시성 기능 등

<br>

#### 아이템60. 정확한 답이 필요하다면 float와 double은 피하라

- float 과 double 타입은 과학과 공학 계산용으로 설계되었음
    - 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 설계되었다
    - 따라서 정확한 결과가 필요할 때는 사용하지말자.
    - 금융 계산에 적합하지않다.
 
- ```"정확한 계산이 필요한 경우 BigDecimal, int 혹은 long 을 사용해야한다."```
    - BigDecimal 단점: 기본 타입보다 쓰기가 훨씬 불편하고 느리다
    - 대안으로 int 혹은 long 타입이 있지만 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야함

- 참고) 숫자를 아홉자리 십진수로 표현할 수 있다면 int, 열여덟 자리까지라면 long, 그 이상은 BigDecimal 사용

<br>

#### 아이템61. 박싱된 기본 타입보다는 기본 타입을 사용하라

- 각각의 기본 타입에 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.
    - ex) int, double, boolean 에 대응하는 박싱된 기본 타입은 Integer, Double, Boolean
 
- 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분없이 사용할 수 있지만 분명한 차이가 있다.
    - 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.
        - 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서도 다를 수 있다
    - 기본 타입의 값은 언제나 유효하지만 박싱된 기본 타입은 유효하지않은 값(null)을 가질 수 있다.
    - 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 효율적이다.
 
- ex) 참조 타입을 사용하여 오류가 발생할 수 있는 코드
    ```java
    Comparator<Integer> naturalOrder =
        (i,j) -> (i < j) ? -1 : (i == j ? 0 : 1)
    ```
    - ```i == j``` 에서 두 객체의 참조값을 비교하게 된다. (결과 false)
    - 이와 같이 박싱된 기본 타입에 ```==``` 연산자 사용 시 오류가 일어날 수 있다.
 
- 실무에서 위와 같이 기본 타입을 다루는 비교자가 필요하면 ```Comparator.naturalOrder()``` 를 사용하자.

- 박싱된 기본 타입과 기본 타입 값을 비교할 때 주의
    - 박싱된 기본 타입의 박싱이 자동으로 풀린다
    - NPE 발생 가능
 
- 박싱된 기본 타입을 쓰기 적절한 경우
    - 컬렉션의 원소, 키, 값으로 쓴다
        - 컬렉션은 기본 타입을 담을 수 없기 때문에
    - 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로 사용
        - 자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문에
        - ex) ```ThreadLocal<int>```` 는 불가능, ```ThreadLocal<Integer>``` 는 가능
    - 리플렉션을 통해 메서드를 호출하는 경우도 박싱된 기본 타입 사용
