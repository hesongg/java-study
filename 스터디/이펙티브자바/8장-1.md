## 이펙티브 자바 스터디

### 8장. 메서드

<br>

#### 아이템49. 매개변수가 유효한지 검사하라

- 메서드와 생성자 대부분은 인자 값이 특정 조건을 만족하기를 바란다
    - ex) 인덱스 값이 음수이면 안된다거나 객체는 null 이 아니여야한다든지 등등
    - 이런 제약은 문서화 필요 및 메서드가 실행되기전에 체크해야한다.

- 메서드 실행 전에 파라미터 체크를 제대로 못한다면
    - 메서드 수행 중간에 모호한 예외를 던지며 실패할 가능성이 있음
    - 더 나쁜 상황 : 메서드가 문제없이 수행되었으나 잘못된 결과를 반환
    - 더더 나쁜 상황 : 메서드 수행 후, 어떤 객체를 이상한 상태로 만들어서 알 수 없는 시점에 메서드와 관련 없는 오류를 유발하는 경우
        - 실패 원자성(failure atomicity)을 어기는 결과를 낳을 수 있음
            - 실패 원자성 : 메서드가 실패한 경우 관련 객체는 메서드 호출전 상태를 가지고있어야함 (item 76)
              
- 매개변수 값이 잘못되었을 때 던지는 예외를 문서화하자 (@throws 자바독 태그)
    - API 사용자가 제약을 지키기 쉬워진다.

- 자바 7 에 추가된 ```java.util.Objects.requireNonNull``` 메서드
    - Object 를 인수로 받아서 null 이 아니면 그대로 반환, null 이면 npe 발생
    - exception message 를 받는 오버로드된 버전이 있음
    - (자바 9 이상) Optional 처럼 default 값을 받는 ```requireNonNullElse```, ```requireNonNullElseGet``` 도 존재

- 위 메서드를 보고 생각나는건데, 객체 값이 null 이거나 특정 조건에 안맞는 경우..
    - exception 발생을 하는게 좋을까? 기본 값으로 리턴하는게 좋을까?
    - 도메인이나 팀내 컨벤션에 따라 다를 것 같은데, 조회 업무에서는 사용자경험을 위해 기본 값을 사용하는게 맞나??

- 자바 9 에 추가된 index 범위 체크 메서드 : checkFromIndexSize, checkFromToIndex, checkIndex
    - 인덱스 체크 조건 미만족 시 ```IndexOutOfBoundsException``` 발생
    - 예외 메세지 설정이 불가능하다고 함
    - 리스트와 배열 전용으로 설계
    - 닫힌 범위(close range)는 다루지 못한다?
        - close range : 시작 인덱스와 끝 인덱스 모두 범위에 포함된다는 것을 의미
            ```java
            //루프의 시작 값(0)과 종료 값(10) 모두를 포함하는 범위를 지정
            for(int i = 0 ; i <= 10 ; i++) {...}
            ```
        - half open range : 범위의 끝 인덱스를 포함하지 않는다는 것을 의미 (일반적인 Java 배열 인덱싱방식과 동일)
            - ```checkFromToIndex(0, 3, length)``` 는 인덱스 0, 1, 2를 검사

- ```assert``` : 유효성 검증
    - false 인 경우 AssertError 예외 발생
    - 보통 개발/테스트 단계에 사용
    - 사용하려면 jvm 옵션 설정해야함 (인텔리제이는 기본으로 설정되어있다고함)

- 메서드에서 직접 사용하지않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써서 체크하자.
    - 나중에 문제가 생겼을 때 디버깅이 어려움

- 메서드 실행 전에 매개변수 유효성 검사해야한다는 규칙에도 예외는 있다.
    - 유효성 검사 비용이 지나치게 높은 경우, 실용적이지 않은 경우, 계산 과정에서 암묵적으로 검사가 수행되는 경우 등
    - 유효성 검사가 중복되서 발생하지 않도록 주의하라는 뜻인듯

- 예외 번역(exception translate) 의 필요성
    - 여러가지 이유로 발생하는 예외들을 API 문서에서 던지기로한 예외로 통일할 필요가 있다.
    - API 사용자의 입장에서 API 문서 외의 예외들은 예상하기 어렵기 때문에?
    - item 73 참고
      
- ```이번 아이템 내용을 "매개변수에 제약을 두는게 좋다" 라고 해석해서는 안된다```
    - 메서드는 최대한 범용적으로 설계되어야하며 매개변수 제약은 적을수록 좋다.
    - 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 드물지 않다.
    - 범용적으로 설계되어야 좋은거지만 구현 목표에 따라 최소한의 제약을 만들자는 뜻인 것 같다

- 메서드나 생성자를 작성할 때 파라미터에 어떤 제약이 있을지 생각해야한다.
    - 그런 중요한 제약 사항들을 문서화하고 메서드 시작 부분에서 명시적으로 검사하자.

<br>

#### 아이템50. 적시에 방어적 복사본을 만들라

- 자바는 네이티브 메서드를 사용하지않아서 메모리 충돌 오류에서 안전한 언어이지만 방어적으로 프로그래밍할 필요성이 있다.

- 외부에서 내부를 수정하는 일을 허락할 수 없게 해야한다.

- 책의 예시) 특정 객체의 불변성을 지키지 못한다
    ```java
    //Period 의 생성자 코드
    public Period(Date start, Date end) {
        ...
        this.start = start;
        this.end = end;
    }

    //문제 코드
    Date start = new Date();
    Date end = new Date();
    Period p = new Period(start, end);
    end.setYear(78); // p 내부 필드가 수정됨
    ```
    - Period 내부의 필드는 private final 로 선언되어있지만 필드 자체가 가변적이기 때문이다.

- 자바 8 에서 위 예시의 가변성을 쉽게 해결 가능하다.
    - Instant, LocalDateTime, ZonedDateTime 은 불변 클래스이다.

- 가변 타입을 사용하는 경우 방어적으로 복사하여 해결 가능
    ```java
    public Period(Date start, Date end) {
        ...
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());
    }
    ```
    - 복사본으로 값을 세팅하는 위 생성자를 사용하면 안전하다.
    - 생성자에서 유효성 검사 필요한 경우 복사본 생성 후에 유효성 검사를 하자.
        - 유효성 검사 과정에서 인자로 받은 필드 값이 변경될 수 있기 때문

- 방어적 복사에 Date 의 clone 메서드를 사용하지 않는 이유?
    - clone 이 원하지 않는 하위 클래스의 인스턴스를 반환할 수 있기 때문에
    - 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone 을 사용해서는 안된다.
 
- 생성자를 수정해서 앞서의 공격은 막을 수 있지만, Period 인스턴스는 아직도 변경 가능
    - 접근자 메서드가 Period 가 가지고 있는 필드를 그대로 반환하기 때문에
    - 이 경우 getter 에서도 방어적 복사본을 만들어서 반환하면 된다.
        ```java
        public Date start() {
            return new Date(start.getTime());
        }
        ```
        - 생성자에서 방어적 복사본을 사용하였다면 getter 에서는 clone 메서드를 사용해도 된다.
            - 해당 필드가 안전하단게 확실하기 때문에
        - 그래도 인스턴스 복사할 때는 생성자나 정적 팩터리를 쓰는게 좋다(item 13)

- 가변적인 객체를 클라이언트에 제공할 때는 반드시 방어적 복사본 구현을 고려하자.
    - 내부 사용 배열 방어적 복사 / 배열의 불변 뷰 반환 (item 15)

- "되도록 불변 객체들을 조합해서 객체를 구성해야 방어적 복사를 할일이 줄어든다."
    - ex) 위 예시의 Period 객체 내부 필드로는 Date 대신에 불변 객체로 구성하자.
        - Instant, LocalDateTime, ZonedDateTime 등

- 방어적 복사는 고려해서 사용하자.
    - 성능 저하 가능성이 있기 때문에 신뢰성있는 클라이언트에게 제공할 때는 생략해도 된다.
    - 또는 불변성이 깨지더라도 영향도가 작은 경우 : 래퍼 클래스 패턴(item 18)

<br>

#### 아이템51. 메서드 시그니처를 신중히 설계하라

- 메서드 이름을 신중히 짓자. 표준 명명 규칙(아이템 68)
    - 이해하기 쉽고, 같은 패키지에 속한 다른 이름들과 일관되게 지어야한다.
    - 긴 이름은 피하고 일반적으로 사용하는 네이밍을 사용하자. (자바 라이브러리 참고)

- 편의 메서드를 너무 많이 만들지 말자.
    - 메서드가 너무 많은 클래스는 사용 및 테스트, 유지보수하기 어렵다.
    - 인터페이스도 마찬가지다, 구현하는 쪽에서 어렵다
    - 편의 메서드를 너무 많이 만들지 말자라는게.. 각 클래스나 인터페이스의 역할에 맞는 메서드만 생성하자는 말인 것 같다
    - ```"아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두길 바란다"``` -> 별도의 약칭 메서드?

- 매개변수 목록은 짧게 유지하자. (4개 이하로?)
    - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우 특히 더 구분하기 어렵다.
        - 매개변수 순서를 바꿔 입력해도 실행되기 때문에 의도와 다르게 동작할 가능성이 높다.
    - 갠 매개변수 목록을 짧게 줄이는 방법?
        - 여러 메서드로 쪼개기
            - ex) ```java.util.List``` 에서 별개로 제공하는 subList, indexOf 메서드
            - 서로 관련 없는 내용들을 하나의 메서드에서 수행한다면..
                - 기능을 원자적으로 쪼개서 여러 메서드를 조합해서 사용하는 방식으로 구현하는 것을 고려해보자.
                    - 그렇다고 사용되지않을 메서드들을 굳이 미리 더 만드는건 안좋지않을까?
                - 무조건 작게 나누는게 좋은건 아니다
                    - API 사용자나 제공 목적, API 가 다루는 개념의 추상화 수준에 맞춰서 조절해야한다.
        - 매개변수 여러 개를 묶어주는 도우미 클래스를 만들기
            - 일반적으로 이런 클래스는 정적 멤버 클래스(아이템 24) 로 둔다.
            - 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있는 경우 효율적이다.
        - 빌더 패턴(아이템 2)을 메서드 호출에 응용
            - 매개변수가 많고, 일부는 생략해도 괜찮은 경우

- 매개변수의 타입으로 클래스보다는 인터페이스가 더 낫다. (아이템 64)
    - ex) 메서드에 HashMap 이나 ArrayList 같은 구현체를 넘기기보다 Map, List 인터페이스를 사용

- boolean 보다 원소 2개짜리 열거 타입이 낫다
    - 코드 가독성이 좋아지고 나중에 확장하기 쉽기 때문에.
    - 메서드 이름상 boolean 을 받아야 의미가 더 명확할 때는 예외
        - 명확하게 true or false 로 나누어지는 케이스에 굳이 이렇게할 필요는 없을듯



