## 이펙티브 자바 스터디

### 6장. 열거 타입과 애너테이션

<br>

#### 아이템34. int 상수 대신 열거 타입을 사용하라
- enum 이 등장하기 전 정수 열거 패턴 (java 1.5 이전)
    - 정수 상수를 묶음 선언하여 사용
        ```java
        public static final int APPLE_RED = 0;
        public static final int APPLE_GREEN = 1;
    
        public static final int ORANGE_TEMPLE = 0;
        public static final int ORANGE_BLOOD = 1;
        ```
    - 단점
        - Type Safety 하지 않음
            - 상수의 값을 정수로만 표현하므로, 다른 정수 상수와 혼동될 수 있음
                ```java
                APPLE_RED == ORANGE_TEMPLE //true 이다. -> 개발자가 의도하지않은 결과 발생
                ```
        - 프린트 문제
        - 상수 값 변경 및 확장 시 리팩토링 어려움
        - 등등.. 매우 많음

- enum
     - 관련있는 상수 값들을 그룹화해서 하나의 타입으로 표현하기위해 사용하는 클래스
     - 외부에 생성자 제공 X -> 싱글톤
     - JVM 에서 enum 을 관리하는 구조
         - enum 상수는 내부적으로 public static final 필드, 메소드 영역에 존재
         - enum 의 인스턴스는 각 enum 상수 별로 생성되어 힙 영역에서 싱글톤으로 관리됨
         - enum 상수는 힙 영역의 인스턴스 참조값을 가르킨다고 보면 된다.
         - 예시)
             ```java
             enum Color {
                 RED, GREEN, BLUE;
             }
             ```
         - 이러한 enum 에서, ```Color.RED```라는 enum 상수를 사용할 때 ```Color``` 타입의 ```RED``` 라는 이름을 가진 싱글턴 인스턴스를 참조
         - 참고) https://honbabzone.com/java/java-enum/
    
    - 예시) 위의 정수 열거 패턴을 enum 으로 표현
        ```java
        public enum Apple {
            RED,
            GREEN
        }

        public enum Orange {
            TEMPLE,
            BLOOD
        }
        ```
    - Type Safety
        - 다른 enum 타입과 비교 시 컴파일 오류 발생
            ```java
            Apple.RED == Orange.TEMPLE //컴파일 오류 발생
            ```
    - 리팩토링 유리
        - ```"상수 순서 변경 및 추가 시 클라이언트에서 다시 컴파일하지않아도 된다."```
            - 상수 순서 변경 및 확장 시에 기존 코드에 영향도가 없음  
    - 프린트
        - ```toString()``` 메서드는 enum 의 name 리턴
    - ```java.lang.Enum.java``` 잠깐 살펴보면..
        ```java
        public abstract class Enum<E extends Enum<E>> implements Constable, Comparable<E>, Serializable {
            
            private final String name;
            private final int ordinal;

            protected Enum(String name, int ordinal) {
                this.name = name;
                this.ordinal = ordinal;
            }

            public String toString() {
                return name;
            }
            ...
        }
        ```
        - enum 사용 시 생성자 호출되어 name, ordinal 값 할당됨
            - name : enum 상수 명
            - oridnal : enum 상수 선언 순서
    - 메서드, 필드 추가 가능
        - 책에 예시가 나오는데.. 많이 사용하는 패턴이라 패스
        - ```"열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다." 등등```
            - 객체지향 관점에서 캡슐화라는 장점 (enum 을 통해서 도메인 로직 관리 이점을 얻을 수 있다.)
    - 여러 인터페이스 구현
        - Object : equals(), hashCode(), toString() 
        - Comparable : compareTo() - ordinal 값으로 비교하도록 구현되어있음
            ```java
            enum Rainbow {
                RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, PURPLE
            }

            // [PURPLE, INDIGO, BLUE, GREEN, YELLOW, ORANGE, RED]
            Arrays.stream(Rainbow.values()).sorted(Comparator.reverseOrder()).toList() 
            ```
        - Serializable : 직/역직렬화 구현
    - ```values()``` : 정의된 상수 값들을 배열로 리턴하는 메서드 제공
        - 참고) 자바 컴파일러에서 메서드 생성
    - 상수 별로 다른 동작 구현 가능 (Override) / 상수별 고유 필드 값 선언 가능
        - enum 에서 선언한 추상 메서드는 각 enum 상수별 클래스 본문(body)에서 구현 가능
        - enum 의 추상 메서드를 각 enum 상수 class body 에서 구현하지않으면 컴파일 오류 발생
        - final field 및 생성자 생성 후 상수에서 선언하지않으면 컴파일 오류 발생
        - 필수로 구현하거나 선언해야하는 추상 메서드, 필드를 컴파일 오류로 명시 가능하다는 장점이 있다.
        ```java
        public enum Operation {
            PLUS("+") {
                @Override
                public double apply(double x, double y) {
                    return x + y;
                }
            },
            ///...생략...

            private final String symbol;

            Operation(String symbol) {
                this.symbol = symbol;
            }
        
            public abstract double apply(double x, double y);
        }
        ```
    - ```valueOf()```
        - String 받아서 동일한 name 을 가지는 enum 상수 리턴
            ```java
            Operation.valueOf("PLUS") == Operation.PLUS //true
            ```
    - enum 에서 ```from~``` 메서드 구현 패턴
        ```java
        private static final Map<String, Operation> stringToEnum = Arrays.stream(values())
                .collect(Collectors.toMap(Operation::getSymbol, Function.identity()));

        public static Operation fromString(String symbol) {
            return stringToEnum.getOrDefault(symbol, PLUS);
        }
        ```
    - 

<br>

#### 아이템35. ordinal 메서드 대신 인스턴스 필드를 사용하라

<br>

#### 아이템36. 비트 필드 대신 EnumSet을 사용하라

<br>

#### 아이템37. ordinal 인덱싱 대신 EnumMap을 사용하라

<br>

#### 아이템38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

