## 이펙티브 자바 스터디

### 6장. 열거 타입과 애너테이션

<br>

#### 아이템34. int 상수 대신 열거 타입을 사용하라
- enum 이 등장하기 전 정수 열거 패턴 (java 1.5 이전)
    - 정수 상수를 묶음 선언하여 사용
        ```java
        public static final int APPLE_RED = 0;
        public static final int APPLE_GREEN = 1;
    
        public static final int ORANGE_TEMPLE = 0;
        public static final int ORANGE_BLOOD = 1;
        ```
    - 단점
        - Type Safety 하지 않음
            - 상수의 값을 정수로만 표현하므로, 다른 정수 상수와 혼동될 수 있음
                ```java
                APPLE_RED == ORANGE_TEMPLE //true 이다. -> 개발자가 의도하지않은 결과 발생
                ```
        - 프린트 문제
        - 상수 값 변경 및 확장 시 리팩토링 어려움
        - 등등.. 매우 많음

- enum
     - 관련있는 상수 값들을 그룹화해서 하나의 타입으로 표현하기위해 사용하는 클래스
     - 외부에서 생성자 호출 불가 -> 싱글톤
     - JVM 에서 enum 을 관리하는 구조
         - enum 상수는 내부적으로 public static final 필드, 메소드 영역에 존재
         - enum 의 인스턴스는 각 enum 상수 별로 생성되어 힙 영역에서 싱글톤으로 관리됨
         - enum 상수는 힙 영역의 인스턴스 참조값을 가르킨다고 보면 된다.
         - 예시)
             ```java
             enum Color {
                 RED, GREEN, BLUE;
             }
             ```
         - 이러한 enum 에서, ```Color.RED```라는 enum 상수를 사용할 때 ```Color``` 타입의 ```RED``` 라는 이름을 가진 싱글턴 인스턴스를 참조
         - 참고) https://honbabzone.com/java/java-enum/
    
    - 예시) 위의 정수 열거 패턴을 enum 으로 표현
        ```java
        public enum Apple {
            RED,
            GREEN
        }

        public enum Orange {
            TEMPLE,
            BLOOD
        }
        ```
    - Type Safety
        - 다른 enum 타입과 비교 시 컴파일 오류 발생
            ```java
            Apple.RED == Orange.TEMPLE //컴파일 오류 발생
            ```
    - 리팩토링 유리
        - ```"상수 순서 변경 및 추가 시 클라이언트에서 다시 컴파일하지않아도 된다."```
            - 상수 순서 변경 및 확장 시에 기존 코드에 영향도가 없음  
    - 프린트
        - ```toString()``` 메서드는 enum 의 name 리턴
    - ```java.lang.Enum.java``` 잠깐 살펴보면..
        ```java
        public abstract class Enum<E extends Enum<E>> implements Constable, Comparable<E>, Serializable {
            
            private final String name;
            private final int ordinal;

            protected Enum(String name, int ordinal) {
                this.name = name;
                this.ordinal = ordinal;
            }

            public String toString() {
                return name;
            }
            ...
        }
        ```
        - enum 사용 시 생성자 호출되어 name, ordinal 값 할당됨
            - name : enum 상수 명
            - oridnal : enum 상수 선언 순서
    - 메서드, 필드 추가 가능
        - 책에 예시가 나오는데.. 많이 사용하는 패턴이라 패스
        - ```"열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다." 등등```
            - 객체지향 관점에서 캡슐화라는 장점 (enum 을 통해서 도메인 로직 관리 이점을 얻을 수 있다.)
    - 여러 인터페이스 구현
        - Object : equals(), hashCode(), toString() 
        - Comparable : compareTo() - ordinal 값으로 비교하도록 구현되어있음
            ```java
            enum Rainbow {
                RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, PURPLE
            }

            // [PURPLE, INDIGO, BLUE, GREEN, YELLOW, ORANGE, RED]
            Arrays.stream(Rainbow.values()).sorted(Comparator.reverseOrder()).toList() 
            ```
        - Serializable : 직/역직렬화 구현
    - ```values()``` : 정의된 상수 값들을 배열로 리턴하는 메서드 제공
        - 참고) 자바 컴파일러에서 메서드 생성
    - 상수 별로 다른 동작 구현 가능 (Override) / 상수별 고유 필드 값 선언 가능
        - enum 에서 선언한 추상 메서드는 각 enum 상수별 클래스 본문(body)에서 구현 가능
        - enum 의 추상 메서드를 각 enum 상수 class body 에서 구현하지않으면 컴파일 오류 발생
        - final field 및 생성자 생성 후 상수에서 선언하지않으면 컴파일 오류 발생
        - 필수로 구현하거나 선언해야하는 추상 메서드, 필드를 컴파일 오류로 명시 가능하다는 장점이 있다.
        ```java
        public enum Operation {
            PLUS("+") {
                @Override
                public double apply(double x, double y) {
                    return x + y;
                }
            },
            ///...생략...

            private final String symbol;

            Operation(String symbol) {
                this.symbol = symbol;
            }
        
            public abstract double apply(double x, double y);
        }
        ```
    - ```valueOf()```
        - String 받아서 동일한 name 을 가지는 enum 상수 리턴
            ```java
            Operation.valueOf("PLUS") == Operation.PLUS //true
            ```
    - enum 에서 ```from~``` 메서드 구현 패턴
        ```java
        private static final Map<String, Operation> stringToEnum = Arrays.stream(values())
                .collect(Collectors.toMap(Operation::getSymbol, Function.identity()));

        public static Operation fromString(String symbol) {
            return stringToEnum.getOrDefault(symbol, PLUS);
        }
        ```
    - 전략 열거 타입 패턴 (상수별 메서드 구현)
        - enum 에서 상수 종류 별로 다른 동작을 수행해야하는 경우 사용
        - 새로운 상수가 추가되어도 큰 수정없이 확장 가능
            ```java
            ElectronicProducts.GALAXY.getLink(); // samsung.com/GALAXY
            ElectronicProducts.IPHONE.getLink() // apple.com/IPHONE
            
            public enum ElectronicProducts {
                GALAXY(SAMSUNG),
                FLIP(SAMSUNG),
                IPHONE(APPLE),
                MACBOOK(APPLE);
            
                private final Company company;
            
                ElectronicProducts(Company company) {
                    this.company = company;
                }
            
                String getLink() {
                    return company.getLink(this);
                }
            
                enum Company {
                    SAMSUNG {
                        @Override
                        String getLink(ElectronicProducts electronicProducts) {
                            return "samsung.com/" + electronicProducts.name();
                        }
                    },
                    APPLE {
                        @Override
                        String getLink(ElectronicProducts electronicProducts) {
                            return "apple.com/" + electronicProducts.name();
                        }
                    };
            
                    abstract String getLink(ElectronicProducts electronicProducts);
                }
            }
            ```
    - 위와 같이 상수별 동작이 깔끔하게 정의 가능하면 전략 열거타입 패턴이 좋지만, 그렇지않으면 switch 문을 사용하는게 좋다.
    - ```"필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자"```
        - 컴파일타임에 그룹화를 할 수 있는 상수 집합은 enum 을 사용하자.
     
<br>

#### 아이템35. ordinal 메서드 대신 인스턴스 필드를 사용하라

- enum 인스턴스 생성 시 enum 상수 선언 순서를 의미하는 ordinal 값이 생성자에서 초기화됨
    - ```ordinal()``` 메서드에서 이 ordinal 값을 리턴한다.
 
- 하지만 상수 선언 순서를 얻기위해 이 메서드를 사용하지말자.
    - 유지보수가 어렵다.
    - 대신에 다른 인스턴스 필드를 선언하여 사용하자.

- ```"oridnal() 은 EnumSet, EnumMap 등의 enum 기반 자료구조에 쓸 목적으로 설계되었다."```
    - 예시) EnumMap 의 put 메서드
        ```java
        Map<Rainbow, Integer> rainbowEnumMap = new EnumMap<>(Rainbow.class);
        
        public V put(K key, V value) {
            typeCheck(key);
    
            int index = key.ordinal();
            Object oldValue = vals[index];
            vals[index] = maskNull(value);
            if (oldValue == null)
                size++;
            return unmaskNull(oldValue);
        }
        ```
        - EnumMap 의 key 는 해당 enum 타입의 상수들로만 이루어진다.
        - 데이터를 배열로 관리하는데..
        - ordinal() 사용하여 enum 상수의 선언 순서로 인덱싱하는 부분을 확인 가능
        - vals.length() == 7 -> enum 의 size 만큼 생성하여 최적화 가능 


<br>

#### 아이템36. 비트 필드 대신 EnumSet을 사용하라

- 과거의 비트 필드 : 정수 열거 패턴의 집합을 표현하기위해 사용
    - 집합 연산 수행 가능
    - 단점
        - 집합 연산 결과를 해석하기 힘듬
        - 유지보수 및 리팩토링이 어렵다

- EnumSet
    - enum 상수 값으로 구성된 집합을 효과적으로 표현 
    - 내부적으로 비트 벡터로 구현되어있음
        - 비트 벡터 : 여러 플래그 값을 하나의 정수로 표현하기위한 데이터 구조
        ```java
        //RegularEnumSet
        private long elements = 0L;
        
        public boolean add(E e) {
            typeCheck(e);
    
            long oldElements = elements;
            elements |= (1L << ((Enum<?>)e).ordinal());
            return elements != oldElements;
        }
        ```
        - ordinal() 사용하여 비트 벡터 구조를 사용하는 내용을 알 수 있음
        - RegularEnumSet 의 경우에 EnumSet 전체를 long 변수 하나로 표현 가능(위 코드의 elements)
     - EnumSet 은 EnumMap 과 다르게 정적 팩토리 메서드로만 제공하는데..
         - Enum 상수 수에 따라 구현체를 다르게 리턴
             - RegularEnumSet or JumboEnumSet
         - 이렇게 내부적으로 최적화를 유지하고 사용자에게 직관적으로 제공하기 위해서 생성자를 제공하지않고 정적 팩토리 메서드를 제공
     - 집합을 다루는 메소드를 수행할 때 발생하는 대량 산술 연산이 구현되어있어 사용자가 직접 비트를 다루면서 발생할 수 있는 오류에서 해방된다.
         

<br>

#### 아이템37. ordinal 인덱싱 대신 EnumMap을 사용하라

<br>

#### 아이템38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

